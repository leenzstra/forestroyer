Public Interface IFace
	Public Property Name: String Get Set End Property Name;
	Public Function Create(a: Integer): Integer;
End Interface IFace;

Public Interface IFace2: IFace
End Interface IFace2;

Public Interface IFace3: IFace2
End Interface IFace3;

/// <summary>
/// 	Узел дерева зависимостей
/// </summary>
Public Class CDependencyTreeNode: Object, IForeIface

	arr: array of Integer[2];
	
	/// <summary>
	/// 	Название узла
	/// </summary>
	Public Shared name, name2, name3: String; 
	
	/// <summary>
	/// 	Список зависимых узлов
	/// </summary>
	Public Dependencies: IArrayList;
	
	/// <summary>
	/// 	Глубина узла (0 - корень, 1+ - узлы)
	/// </summary>
	Public Depth: Integer;

	Function Test1;
	Begin
	End function test1;
	
	/// <summary>
	/// 	Конструктор
	/// </summary>
	Public Constructor Create(name: String);
	Const
		C_VAR1 = "Name";
		C_VAR2 = 1;
	Const CVAR3 = "asd";
	Var
		name: Variant = 1;
		name2: Array of Integer[1] = [1];
		name3: Array[3] = [1, 2, 3 + C_VAR2];
		name4: IArrayList;
		name5: IArrayList;
	Begin
		Inherited Create(name);

		Raise new Exception.Create(asd);
		Raise e;
		Dispose file;

		For each node in nodes Do
			break;
			continue;
			return;
		End for;

		if True Then
			a := 5;
		Elseif False Then
			a := 6;
		Elseif 1 = 1 Then
			a := 7;
		Else
			a := 8;
		end if;

		Try
			Debug.WriteLine("0");
			//Raise New IndexOutOfRangeException.Create("asd");
		Except On e: IndexOutOfRangeException Do
			Debug.WriteLine("1");
		On e: FileAlreadyExistsException Do
			Debug.WriteLine("2");
		Else
			Debug.WriteLine("3");
		Finally
			Debug.WriteLine("4");
		End Try;

		Try
			Debug.WriteLine("1");
			//Raise New IndexOutOfRangeException.Create("asd");
		Except
			Debug.WriteLine("2");
		Else
			Debug.WriteLine("3");
		Finally
			Debug.WriteLine("4");
		End Try;

		Try
			Debug.WriteLine("1");
		Except
			Debug.WriteLine("2");
		Finally
			Debug.WriteLine("4");
		End Try;

		Try
			Debug.WriteLine("1");
		Finally
			Debug.WriteLine("4");
		End Try;

		Try
			Debug.WriteLine("1");
		Except
			Debug.WriteLine("2");
		End Try;

		Try
			Debug.WriteLine("1");
		Except On e: Exception Do
			Debug.WriteLine("2");
		End Try;
		
    	Dependencies := New ArrayList.Create;
		Depth := 0;

		return;
	End Constructor Create;
	
End Class CDependencyTreeNode;



/// <summary>
/// 	Дерево зависимостей
/// </summary>
Public Class CDependencyTree: Object
	
	_root: CDependencyTreeNode; // корень дерева
	_nodes: IHashtable; // список всех узлов дерева
	
	/// <summary>
	/// 	Конструктор
	/// </summary>
	Public Constructor Create;
	Begin
		_root := Null;
		_nodes := New Hashtable.Create;
	End Constructor Create;
	
	/// <summary>
	/// 	Получение глубины дерева
	/// </summary>
	Public Function GetTreeDepth: Integer;
	Var
		maxDepth: Integer;
		node: CDependencyTreeNode;
	Begin
		For Each node In _nodes Do
			If maxDepth < node.Depth Then
				maxDepth := node.Depth;
			End If; 	
		End For;
		Return maxDepth;
	End Function GetTreeDepth;
	
	/// <summary>
	/// 	Построение структуры дерева на основе хэш-таблицы зависимостей
	/// </summary>
	Public Sub Build(dependencies: IHashtable);
	Var
		name, dep: Variant;
		treeNode, depTreeNode: CDependencyTreeNode;
		deps: ICollection;
	Begin
		// Создаем узлы
		For Each name In dependencies.Keys Do
			_nodes.Item(name) := New CDependencyTreeNode.Create(name);
			
			deps := dependencies.Item(name);
			For Each dep In deps Do
				If Not _nodes.ContainsKey(dep) Then
					_nodes.Item(dep) := New CDependencyTreeNode.Create(dep);
				End If;
			End For;
		End For;

        a := -1;
        a := "asd";
        a := -1.0;
        a := b;
		
		// Указываем зависимости узлов
		For Each name In dependencies.Keys Do
			deps := dependencies.Item(name);
			treeNode := _nodes.Item(name);
			For Each dep In deps Do
				depTreeNode := _nodes.Item(dep);
				treeNode.Dependencies.Add(depTreeNode);
			End For;
		End For;
		
		// Формирование корня
		CreateRoot;
		
		// Подсчет глубины для каждого узла дерева
		CalculateDepths;
	End Sub Build;
	
	/// <summary>
	/// 	Построение структуры дерева на основе графа
	/// </summary>
	Public Sub BuildFromGraph(graph: CDependencyGraph);
	Begin
		Build(graph.Graph);
	End Sub BuildFromGraph;
	
	/// <summary>
	/// 	Создание корневого узла
	/// </summary>
	Sub CreateRoot;
	Var
		nodes: IArrayList;
	Begin	
		nodes := New ArrayList.Create;
		nodes.AddRange(_nodes.Values);
		
		_root := New CDependencyTreeNode.Create("ROOT");
		_root.Dependencies := nodes;
	End Sub CreateRoot;
	
	/// <summary>
	/// 	Подсчет глубины для узлов дерева
	/// </summary>
	Sub CalculateDepths(node: CDependencyTreeNode = Null; depth: Integer = 0);
	Var
		child: CDependencyTreeNode;
	Begin
		If IsNull(node) Then
			node := _root;
		End If;
		
		// По умолчанию глубина узла = 0, поэтому минимум 1 раз в это условие зайдет каждая.
		// Также если у зависимости уже указана глубина, но она оказалась более глубокая, то ставим ее глубже
		If depth > node.Depth Then
			node.Depth := depth;
		End If;

		For Each child In node.Dependencies Do
			CalculateDepths(child, depth + 1);
		End For;
	End Sub CalculateDepths;
	
	/// <summary>
	/// 	Получение узлов дерева по уровням (ключ - глубина, значение - CDependencyTreeNode).
	/// 	Корень исключается
	/// </summary>
	Public Function GetNodesByLevels: IHashtable;
	Var
		levelNodes: IHashtable;
		node: CDependencyTreeNode;
	Begin
		levelNodes := New Hashtable.Create;
		For Each node In _nodes Do
			If Not levelNodes.ContainsKey(node.Depth) Then
				levelNodes.Add(node.Depth, New ArrayLIst.Create);
			End If;
			(levelNodes.Item(node.Depth) As IArrayList).Add(node);
		End For;
		Return levelNodes;
	End Function GetNodesByLevels;
	
	/// <summary>
	/// 	Вывод дерева в консоль
	/// </summary>
	Public Sub Print(writer: IWriter);
	Var
		child: CDependencyTreeNode;
	Begin
		For Each child In _nodes Do
			writer.Write(String.Format("{0} {1} [{2}]", String.Space(child.Depth * 2), child.Name, child.Depth));
		End For;
	End Sub Print;
	
End Class CDependencyTree;



/// <summary>
/// 	Граф зависимостей (на основе хэш-таблицы)
/// </summary>
Class CDependencyGraph: Object
	
	_graph: IHashtable;
	
	/// <summary>
	/// 	Хэш-таблица зависимостей (ключ - объект, значение - множество зависимостей (объектов)).
	/// 	{ Variant: IHashtable { Variant: True } }
	/// </summary>
	Public Property Graph: IHashtable
		Get Begin Return _graph; End Get
	End Property Graph;
	
	/// <summary>
	/// 	Множество зависимостей
	/// </summary>
	Public Property Dependencies(node: Variant): IHashtable
		Get Begin Return (_graph.Item(node) As Hashtable); End Get
		Set Begin _graph.Item(node) := value; End Set
	End Property Dependencies;

	/// <summary>
	/// 	Конструктор
	/// </summary>
	Public Constructor Create;
	Begin
		_graph := New Hashtable.Create;
	End Constructor Create;
	
	Public Sub AddDependency(node, dependency: Variant);
	Begin
		AddEmptyNode(node);
		Dependencies(node).Item(dependency) := True;
	End Sub AddDependency;
	
	/// <summary>
	/// 	Добавить объект без зависимостей (либо перезаписать)
	/// </summary>
	Public Sub AddEmptyNode(node: Variant; replace: Boolean = False);
	Begin
		If Not _graph.Contains(node) Or replace Then
			Dependencies(node) := New Hashtable.Create;
		End If;
	End Sub AddEmptyNode;
	
	/// <summary>
	/// 	Получение множества зависимостей объекта в виде списка объектов
	/// </summary>
	Public Function GetDependenciesValues(node: Variant): ICollection;
	Begin
		AddEmptyNode(node);
		Return Dependencies(node).Keys;
	End Function GetDependenciesValues;
	
End Class CDependencyGraph;



/// <summary>
/// 	Граф зависимостей таблиц
/// </summary>
Class CTableDependencyGraph: CDependencyGraph
	
	_tables: IArrayList; // [ITable] список всех таблиц, на основе которых строится граф
	_visited: IHashtable; // посещенные таблицы, антицикл
	_tableInfos: IArrayList; // [DbObjectInfo] список описаний исходных таблиц
	_db: IDatabase; // БД, к которой относятся все таблицы
	
	/// <summary>
	/// 	Конструктор
	/// </summary>
	/// <param name="tableInfos">Список описаний выбранных таблиц (DbObjectInfo)</param>
	/// <param name="db">БД</param>
	Public Constructor Create(tableInfos: IArrayList; db: IDatabase);
	Begin
		Inherited Create;
		
		_visited := New Hashtable.Create;
		_tables := New ArrayList.Create;
		_tableInfos := tableInfos;
		_db := db;
	End Constructor Create;
	
	/// <summary>
	/// 	Получение информации о предоставленных таблицах
	/// </summary>
	Sub PrepareProvidedTables;
	Var
		info: DbObjectInfo;
	Begin
		For Each info In _tableInfos Do
			_tables.Add(info.MbDesc.Bind As ITable);
		End For;
	End Sub PrepareProvidedTables;
	
	/// <summary>
	/// 	Получение информации о всех таблицах БД (которые есть в репозитории)
	/// </summary>
	Sub PrepareAllTables;
	Var
		descriptors: IMetabaseObjectDescriptors;
		desc: IMetabaseObjectDescriptor;
		filtered: IArrayList;
	Begin
		// поиск всех таблиц от корня репо
		descriptors := GetObjectChildrenOfClass(MbExt.Item(0), AsIntArray(MetabaseObjectClass.KE_CLASS_TABLE, MetabaseObjectClass.KE_CLASS_EXTERNTABLE));
		// фильтр таблиц по БД
		filtered := FilterDescriptorsByDb(descriptors, _db);
		For Each desc In filtered Do
			_tables.Add(desc.Bind As ITable);
		End For;
	End Sub PrepareAllTables;
	
	/// <summary>
	/// 	Построение графа зависимостей
	/// </summary>
	/// <param name="recursive">Рекурсивный поиск зависимостей</param>
	/// <param name="onlyProvidedTables">Признак поиска зависимостей только среди предоставленных таблиц</param>
	Public Sub BuildDependencyGraph(recursive, onlyProvidedTables: Boolean);
	Var
		tableInfo: DbObjectInfo;
	Begin
		If onlyProvidedTables Then
			PrepareProvidedTables;
		Else
			PrepareAllTables;
		End If;

		For Each tableInfo In _tableInfos Do
			FindTableDependencies(tableInfo.MbDesc.Bind As ITable, recursive);
		End For;
	End Sub BuildDependencyGraph;
	
	/// <summary>
	/// 	Поиск зависимых таблиц для указанной таблицы
	/// </summary>
	Sub FindTableDependencies(table: ITable; recursive: Boolean);
	Var
		fk: ITableForeignKey;
		dbName, fkTableDbName: String;
		tmpTable, fkTable: ITable;
	Begin
		If IsNull(table) Then
			Return;
		End If;
		
		// Физическое имя таблицы со схемой
		dbName := CreateTableDbName(table);
		AddEmptyNode(dbName);
		_visited.Item(dbName) := table;
		
		For Each fk In table.ForeignKeys Do
			// поиск зависимой таблицы по внешнему ключу
			For Each tmpTable In _tables Do
				If String.ToLower(tmpTable.CaseSensitiveNativeName) = String.ToLower(fk.RTable) Then
					fkTable := tmpTable;
					Break;
				End If;
			End For;
			
			// Если зависимой таблицы нет в репо (только в БД), то не добавляем ее
			If IsNull(fkTable) Then
				Continue;
			End If;
			
			// Добавляем зависимость в граф
			fkTableDbName := CreateTableDbName(fkTable);
			AddDependency(dbName, fkTableDbName);
			
			// Если еще не посещали зависимую таблицу, то рекурсивно ищем зависимости для нее
			If Not _visited.Contains(fkTableDbName) And recursive Then
				FindTableDependencies(fkTable, recursive);
			End If;
		End For;
	End Sub FindTableDependencies;
	
	/// <summary>
	/// 	Получить список всех таблиц в графе (ITable)
	/// </summary>
	Public Function GetTables: IArrayList;
	Var
		tables: IArrayList;
		table: ITable;
	Begin
		tables := New ArrayList.Create;
		For Each table In _visited.Values Do
			tables.Add(table);
		End For;
		Return tables;
	End Function GetTables;
	
End Class CTableDependencyGraph;

/// <summary>
/// 	Обновление списка информации о таблицах, добавив зависимые таблицы для указанной БД
/// </summary>
/// <param name="tableInfos">Список информации о таблицах (DbObjectInfo)</param>
/// <param name="db">БД</param>
/// <returns>Обновленный список информации о таблицах</returns>
Public Function GetTablesWithDependencies(tableInfos: IArrayList; db: IDatabase): IArrayList;
Var
	graph: CTableDependencyGraph;
	tables, updatedTableInfos: IArrayList;
	table: ITable;
	tableInfo: DbObjectInfo;
Begin
	// Строим граф зависимостей таблиц
	graph := New CTableDependencyGraph.Create(tableInfos, db);
	graph.BuildDependencyGraph(True, False);
	
	// Получаем все таблицы в графе
	tables := graph.GetTables;
	
	// Трансформируем ITable в DbObjectInfo
	updatedTableInfos := New ArrayList.Create;
	For Each table In tables Do
		tableInfo := New DbObjectInfo.Create;
		tableInfo.DbName := CreateTableDbName(table);
		tableInfo.MbDesc := table As IMetabaseObjectDescriptor;
		updatedTableInfos.Add(tableInfo);
	End For;
	
	Return updatedTableInfos;
End Function GetTablesWithDependencies;

/// <summary>
/// 	Сортировка таблицы в порядке зависимости для указанной БД
/// </summary>
/// <param name="tableInfos">Список информации о таблицах (DbObjectInfo)</param>
/// <param name="db">БД</param>
/// <returns>Обновленный список информации о таблицах</returns>
Public Function GetDependenceOrderedTables(tableInfos: IArrayList; db: IDatabase): IArrayList;
Var
	graph: CTableDependencyGraph;
	tree: CDependencyTree;
	tableDbNameMapping, leveledNodes: IHashtable;
	tables, orderedDbNames, orderedTables, nodes: IArrayList;
	node: CDependencyTreeNode;
	table: ITable;
	level: Integer;
	dbName: String;
	tableObject: DbObjectInfo;
Begin
	// Строим граф зависимостей таблиц и получаем все таблицы
	graph := New CTableDependencyGraph.Create(tableInfos, db);
	graph.BuildDependencyGraph(True, True);
	tables := graph.GetTables;
	
	// Строим дерево
	tree := New CDependencyTree.Create;
	tree.Build(graph.Graph);
	//tree.Print;
	
	// Формируем список имен таблиц в порядке зависимости
	orderedDbNames := New ArrayList.Create;
	leveledNodes := tree.GetNodesByLevels;
	For level := tree.GetTreeDepth To 0 Step -1 Do
		nodes := leveledNodes.Item(level);
		If Not IsNull(nodes) Then
			For Each node In nodes Do
				orderedDbNames.Add(node.Name);
			End For;
		End If;
	End For;
	
	// Маппинг физического имени таблицы и объекта ITable
	tableDbNameMapping := New Hashtable.Create;
	For Each table In tables Do
		dbName := CreateTableDbName(table);
		tableDbNameMapping.Item(dbName) := table;
	End For;
	
	// Формирование описаний таблиц DbObjectInfo
	orderedTables := New ArrayList.Create;
	For Each dbName In orderedDbNames Do
		If tableDbNameMapping.ContainsKey(dbName) Then
			table := tableDbNameMapping.Item(dbName);
			tableObject := New DbObjectInfo.Create;
			tableObject.DbName := dbname;
			tableObject.MbDesc := table As IMetabaseObject;
			orderedTables.Add(tableObject);
		End If;
	End For;
	
	Return orderedTables;
End Function GetDependenceOrderedTables;

/// <summary>
/// 	Фильтрация описаний объектов БД (DbObjectInfo) по классам с возможность инвертирования
/// </summary>
/// <param name="dbObjects">Список информации о объектах БД (DbObjectInfo)</param>
///	<param name="classIds">Фильтр, массив типов объектов репозитория</param>
/// <param name="invert">Признак инвертирования фильтра</param>
/// <returns>Отфильтрованный список описаний объектов</returns>
Function FilterDbObjects(dbObjects: IArrayList; classIds: Array Of Integer; invert: Boolean = False): IArrayList;
Var
	filtered: IArrayList;
	dbObject: DbObjectInfo;
Begin
	filtered := New ArrayList.Create;
	For Each dbObject In dbObjects Do
		If Not IsNull(dbObject.MbDesc) Then
			If Not invert And (classIds.IndexOf(dbObject.MbDesc.ClassId) <> -1) Then
				filtered.Add(dbObject);
			Elseif invert And (classIds.IndexOf(dbObject.MbDesc.ClassId) = -1) Then 
				filtered.Add(dbObject);
			End If;
		End If;
	End For;
	Return filtered;
End Function FilterDbObjects;

Const
	// [по умолчанию] Ключ контейнера
	C_DEFAULT_CONTAINER_KEY = 0;
	// [по умолчанию] Ключ подключения к БД
	C_DEFAULT_DB_KEY = 0;
	// [по умолчанию] Ключ подключения к БД для переноса
	C_DEFAULT_TARGET_DB_KEY = 0;
	// [по умолчанию] Название схемы БД для переноса
	C_DEFAULT_TARGET_SCHEMA = "";
	// [по умолчанию] Файл для записи всех SQL объектов
	C_DEFAULT_SQL_FILE_PATH = "";
	// [по умолчанию] Признак сортировки таблиц в порядке зависимости (на основе внешних ключей)
	C_DEFAULT_TABLE_DEPENDENCY_ORDER = True;
	// [по умолчанию] Признак изменения зависимостей таблиц (на основе внешних ключей)
	C_DEFAULT_TABLE_ADD_DEPENDENCIES = True;
	
	// Признак экранирования названий объектов в БД
	C_ESCAPE_DB_OBJECT_NAMES = False;
	
	// Идентификатор справочника с объектами БД
	C_DB_OBJECTS_DIM_ID = "DICT_SCHEMAMIGRATION_OBJECTS";
	// Идентификатор таблицы с объектами БД
	C_DB_OBJECTS_TBL_ID = "TBL_SCHEMAMIGRATION_OBJECTS";
	// Идентификатор компонента
	C_NAMESPACE = "DEVELOPER_ENGINE";
	
/// <summary>
/// 	Тип скрипта
/// </summary>
Public Enum EScriptType
	Alter = 1,
	Drop = 2
End Enum EScriptType;

/// <summary>
/// 	Адреса ячеек с параметрами генератора скриптов переноса объектов БД между схемами
/// </summary>
Public Class CSchemaMigrationReportLocations: Object
	
	// Лист с настройками
	Public Const SETTINGS_LIST_INDEX = 0;
	Public Const CONTAINER_KEY = "C2";
	Public Const DB_KEY = "C3";
	Public Const TARGET_SCHEMA = "C4";
	Public Const SQL_EXECUTABLES_FILE_PATH = "C5";
	Public Const TARGET_DB_KEY = "C6";
	Public Const ENABLE_TABLE_DEPENDENCY_ORDER = "C7";
	Public Const ENABLE_TABLE_ADD_DEPENDENCIES = "C8";
	
	// Лист с командами ALTER
	Public Const ALTER_COMMANDS_LIST_INDEX = 0;
	Public Const ALTER_COMMANDS_START_CELL = "B10";
	
	// Лист с командами DROP
	Public Const DROP_COMMANDS_LIST_INDEX = 1;
	Public Const DROP_COMMANDS_START_CELL = "B1";
	
	// Лист с персистентными объектами БД (таблицы, процедуры)
	Public Const DB_PERSISTENT_OBJECTS_LIST_INDEX = 2;
	
	// Лист с неперсистентными объектами БД (запросы, команды СУБД)
	Public Const DB_NONPERSISTENT_OBJECTS_LIST_INDEX = 3;
	
	// Столбец с командами для переноса
	Public Const DB_COMMANDS_COLUMN = 7;
	Public Const DB_COMMANDS_ROW = 4;
	
	// Столбец с измененениями подключения
	Public Const DB_CHANGED_OBJECTS_COLUMN = 8;
	Public Const DB_CHANGED_OBJECTS_ROW = 4;
	
End Class CSchemaMigrationReportLocations;

/// <summary>
/// 	Параметры конфигурации миграции
/// </summary>
Public Class CSchemaMigrationConfig: Object
	
	Public ContainerKey: Integer;
	Public DatabaseKey: Integer;
	Public TargetSchema: String;
	Public TargetDatabaseKey: Integer;
	Public SqlExecutablesFilePath: String;
	Public EnableTableDependencyOrder: Boolean;
	Public EnableTableAddDependencies: Boolean;
	
	/// <summary>
	/// 	Контейнер, папка и т.д.
	/// </summary>
	Public Property Container: IMetabaseObjectDescriptor
		Get Begin Return MbExt.Item(ContainerKey); End Get
	End Property Container;

	/// <summary>
	/// 	Объект подключения к БД, для которого выполняется поиск
	/// </summary>
	Public Property Database: IDatabase
		Get Begin Return MbExt.Item(DatabaseKey).Bind As IDatabase; End Get
	End Property Database;
	
	/// <summary>
	/// 	Объект подключения к БД, в которую переносятся объекты
	/// </summary>
	Public Property TargetDatabase: IDatabase
		Get Begin Return MbExt.Item(TargetDatabaseKey).Bind As IDatabase; End Get
	End Property TargetDatabase;
	
	/// <summary>
	/// 	Конструктор с параметрами с листа
	/// </summary>
	Public Constructor CreateFromSheet(sheet: IPrxSheet);
	Begin
		ReadFromSheet(sheet);
	End Constructor CreateFromSheet;
	
	/// <summary>
	/// 	Конструктор с параметрами с листа настроек
	/// </summary>
	Public Constructor CreateFromPredefinedSheet(report: IPrxReport);
	Begin
		ReadFromSheet(CSheetsManager.GetSettingsSheet(report));
	End Constructor CreateFromPredefinedSheet;
	
	/// <summary>
	/// 	Конструктор
	/// </summary>
	Public Constructor CreateDefault;
	Begin
		ContainerKey := C_DEFAULT_CONTAINER_KEY;
		DatabaseKey := C_DEFAULT_DB_KEY;
		TargetSchema := C_DEFAULT_TARGET_SCHEMA;
		TargetDatabaseKey := C_DEFAULT_TARGET_DB_KEY;
		SqlExecutablesFilePath := C_DEFAULT_SQL_FILE_PATH;
		EnableTableDependencyOrder := C_DEFAULT_TABLE_DEPENDENCY_ORDER;
		EnableTableAddDependencies := C_DEFAULT_TABLE_ADD_DEPENDENCIES;
	End Constructor CreateDefault;
	
	/// <summary>
	/// 	Чтение настроек с листа
	/// </summary>
	Private Sub ReadFromSheet(sheet: IPrxSheet);
	Var
		tab: ITabSheet;
	Begin
		tab := sheet As ITabSheet;
		ContainerKey :=  tab.ParseCell(CSchemaMigrationReportLocations.CONTAINER_KEY).Value; 
		DatabaseKey := tab.ParseCell(CSchemaMigrationReportLocations.DB_KEY).Value; 
		TargetSchema := tab.ParseCell(CSchemaMigrationReportLocations.TARGET_SCHEMA).Value; 
		TargetDatabaseKey := tab.ParseCell(CSchemaMigrationReportLocations.TARGET_DB_KEY).Value; 
		SqlExecutablesFilePath := tab.ParseCell(CSchemaMigrationReportLocations.SQL_EXECUTABLES_FILE_PATH).Value; 
		EnableTableDependencyOrder := tab.ParseCell(CSchemaMigrationReportLocations.ENABLE_TABLE_DEPENDENCY_ORDER).Value; 
		EnableTableAddDependencies := tab.ParseCell(CSchemaMigrationReportLocations.ENABLE_TABLE_ADD_DEPENDENCIES).Value; 
	End Sub ReadFromSheet;
	
	/// <summary>
	/// 	Запись настроек на лист
	/// </summary>
	Public Sub WriteToSheet(sheet: IPrxSheet);
	Var
		tab: ITabSheet;
	Begin
		tab := sheet As ITabSheet;
		tab.ParseCell(CSchemaMigrationReportLocations.CONTAINER_KEY).Value := ContainerKey; 
		tab.ParseCell(CSchemaMigrationReportLocations.DB_KEY).Value := DatabaseKey; 
		tab.ParseCell(CSchemaMigrationReportLocations.TARGET_SCHEMA).Value := TargetSchema; 
		tab.ParseCell(CSchemaMigrationReportLocations.TARGET_DB_KEY).Value := TargetDatabaseKey; 
		tab.ParseCell(CSchemaMigrationReportLocations.SQL_EXECUTABLES_FILE_PATH).Value := SqlExecutablesFilePath; 
		tab.ParseCell(CSchemaMigrationReportLocations.ENABLE_TABLE_DEPENDENCY_ORDER).Value := EnableTableDependencyOrder; 
		tab.ParseCell(CSchemaMigrationReportLocations.ENABLE_TABLE_ADD_DEPENDENCIES).Value := EnableTableAddDependencies; 
	End Sub WriteToSheet;
	
	/// <summary>
	/// 	Запись конфигурации на лист настроек
	/// </summary>
	Public Sub WriteToPredefinedSheet(report: IPrxReport);
	Begin
		WriteToSheet(CSheetsManager.GetSettingsSheet(report));
	End Sub WriteToPredefinedSheet;
	
End Class CSchemaMigrationConfig;

/// <summary>
/// 	Класс управления листами
/// </summary>
Public Class CSheetsManager: Object
	
	/// <summary>
	/// 	Получить лист настроек
	/// </summary>
	Public Shared Function GetSettingsSheet(report: IPrxReport = Null): IPrxSheet;
	Begin
		Return FindSheet(CSchemaMigrationReportLocations.SETTINGS_LIST_INDEX, report);
	End Function GetSettingsSheet;
	
	/// <summary>
	/// 	Получить лист команд ALTER
	/// </summary>
	Public Shared Function GetAlterCommandsSheet(report: IPrxReport = Null): IPrxSheet;
	Begin
		Return FindSheet(CSchemaMigrationReportLocations.ALTER_COMMANDS_LIST_INDEX, report);
	End Function GetAlterCommandsSheet;
	
	/// <summary>
	/// 	Получить лист команд DROP
	/// </summary>
	Public Shared Function GetDropCommandsSheet(report: IPrxReport = Null): IPrxSheet;
	Begin
		Return FindSheet(CSchemaMigrationReportLocations.DROP_COMMANDS_LIST_INDEX, report);
	End Function GetDropCommandsSheet;
	
	/// <summary>
	/// 	Получить персистентных объектов БД
	/// </summary>
	Public Shared Function GetPersistentDatabaseObjectsSheet(report: IPrxReport = Null): IPrxSheet;
	Begin
		Return FindSheet(CSchemaMigrationReportLocations.DB_PERSISTENT_OBJECTS_LIST_INDEX, report);
	End Function GetPersistentDatabaseObjectsSheet;
	
	/// <summary>
	/// 	Получить неперсистентных объектов БД
	/// </summary>
	Public Shared Function GetNonPersistentDatabaseObjectsSheet(report: IPrxReport = Null): IPrxSheet;
	Begin
		Return FindSheet(CSchemaMigrationReportLocations.DB_NONPERSISTENT_OBJECTS_LIST_INDEX, report);
	End Function GetNonPersistentDatabaseObjectsSheet;
	
	/// <summary>
	/// 	Поиск листа отчета
	/// </summary>
	Private Shared Function FindSheet(index: Integer; report: IPrxReport = Null): IPrxSheet;
	Var
		sheets: IPrxSheets;
	Begin
		report := ReportExt.Report(report);
		sheets := report.Sheets;
		
		If (index < 0) Or (index >= sheets.Count) Then
			Return Null;
		End If;
		
		Return sheets.Item(index);
	End Function FindSheet;
	
End Class CSheetsManager;

/// <summary>
/// 	Приведение IPrxSheet к ITabSheet
/// </summary>
Public Function AsTabSheet(sheet: IPrxSheet): ITabSheet;
Begin
	Return IsNull(sheet) ? Null : (sheet As IPrxTable).TabSheet;
End Function AsTabSheet;

/// <summary>
/// 	Очистка отчета
/// </summary>
/// <param name="report">РО</param>
Sub ClearScripts(Report: IPrxReport);
Begin
	ClearAlterSheet(report);
	ClearDropSheet(report);
	ClearDbCommands(report);
	ClearConnChanges(report);
End Sub ClearScripts;

/// <summary>
/// 	Очистка DROP записей с листа
/// </summary>
/// <param name="report">РО</param>
Sub ClearDropSheet(report: IPrxReport);
Var
	dropCmdsSheet: ITabSheet;
	dropCmdsStartCell, range: ITabRange;
Begin
	Try
		dropCmdsSheet := AsTabSheet(CSheetsManager.GetDropCommandsSheet(report));
		dropCmdsSheet.BeginUpdate;
		
		dropCmdsStartCell := dropCmdsSheet.ParseCell(CSchemaMigrationReportLocations.DROP_COMMANDS_START_CELL);
		range := dropCmdsSheet.Cells(dropCmdsStartCell.Top, dropCmdsStartCell.Left, dropCmdsSheet.RowsCount - 1,  dropCmdsStartCell.Left); 
		range.ClearPart(TabCleanPart.Value);
	Finally
		dropCmdsSheet.EndUpdate;
	End Try;
End Sub ClearDropSheet;

/// <summary>
/// 	Очистка ALTER записей с листа
/// </summary>
/// <param name="report">РО</param>
Sub ClearAlterSheet(report: IPrxReport);
Var
	alterCmdsSheet: ITabSheet;
	alterCmdsStartCell, range: ITabRange;
Begin
	Try
		alterCmdsSheet := AsTabSheet(CSheetsManager.GetAlterCommandsSheet(report));
		alterCmdsSheet.BeginUpdate;
		
		alterCmdsStartCell := alterCmdsSheet.ParseCell(CSchemaMigrationReportLocations.ALTER_COMMANDS_START_CELL);
		range := alterCmdsSheet.Cells(alterCmdsStartCell.Top, alterCmdsStartCell.Left, alterCmdsSheet.RowsCount - 1,  alterCmdsStartCell.Left); 
		range.ClearPart(TabCleanPart.Value);	
	Finally
		alterCmdsSheet.EndUpdate;
	End Try;
End Sub ClearAlterSheet;

/// <summary>
/// 	Очистка истории изменения подключений с листа
/// </summary>
/// <param name="report">РО</param>
Sub ClearConnChanges(report: IPrxReport);
Var
	sheet: ITabSheet;
	range: ITabRange;
Begin
	Try
		sheet := AsTabSheet(report.ActiveSheet);
		sheet.BeginUpdate;
		
		range := sheet.Column(CSchemaMigrationReportLocations.DB_CHANGED_OBJECTS_COLUMN);
		range.Clear;
	Finally
		sheet.EndUpdate;
	End Try;
End Sub ClearConnChanges;

/// <summary>
/// 	Очистка команд переноса с активного листа
/// </summary>
/// <param name="report">РО</param>
Sub ClearDbCommands(report: IPrxReport);
Var
	sheet: ITabSheet;
	range: ITabRange;
Begin
	Try
		sheet := AsTabSheet(report.ActiveSheet);
		sheet.BeginUpdate;
		
		range := sheet.Column(CSchemaMigrationReportLocations.DB_COMMANDS_COLUMN);
		range.Clear;
	Finally
		sheet.EndUpdate;
	End Try;
End Sub ClearDbCommands;

/// <summary>
/// 	Очистка отчета
/// </summary>
/// <param name="report">РО</param>
Public Sub ClearScriptsHandler(Report: IPrxReport);
Begin
	ClearScripts(report);
End Sub ClearScriptsHandler;

/// <summary>
/// 	Поиск объектов схемы (действие кнопки)
/// </summary>
/// <param name="report">РО</param>
Public Sub GetSchemaObjectsHandler(report: IPrxReport);
Begin
	GetSchemaObjects(report);
End Sub GetSchemaObjectsHandler;

/// <summary>
/// 	Изменения подключений к БД у выбранных записей в ТО (действие кнопки)
/// </summary>
Public Sub ChangeConnectionsOfSelectionHandler(report: IPrxReport);
Begin
	ChangeConnectionsOfSelection(report);
End Sub ChangeConnectionsOfSelectionHandler;

/// <summary>
/// 	Изменение подключений всех объектов (таблицы, процедуры, запросы, команды СУБД) (действие кнопки)
/// </summary>
Sub ChangeAllConnectionsHandler(report: IPrxReport);
Begin
	ChangeAllConnections(report);
End Sub ChangeAllConnectionsHandler;

/// <summary>
/// 	Сгенерировать скрипты на активном листе для выбранных объектов в ТО (действие кнопки)
/// </summary>
Sub GenerateScriptsForSelectionHandler(report: IPrxReport);
Begin
	GenerateScriptsForSelection(report);
End Sub GenerateScriptsForSelectionHandler;

/// <summary>
/// 	CSchemaMigrationReportHandler
/// </summary>
Public Class CSchemaMigrationReportHandler: CCheckboxesEvents
	
	Sub OnBeforeOpenReport(report: IPrxReport; Var cancel: Boolean);
	Begin
		Inherited OnBeforeOpenReport(report, cancel);
		
		// Удаление предыдущих объектов из таблицы
		ClearDbObjectsTable;
		
		// Заполнение настроечного листа настройками по умолчанию
		(New CSchemaMigrationConfig.CreateDefault).WriteToPredefinedSheet(report);
	End Sub OnBeforeOpenReport;
	
End Class CSchemaMigrationReportHandler;

Sub SelectCaseSample;
Var
    a, c: Integer;
Begin
    //...
    //Получение значений a, b, c
    //...
    Select Case a
		Case 2 To 5, 6 To 7, 8: Return;
        Case 1, 2, 3: c := c + 5;
        Case 2 To 5: c := c + 4;
        Case 3: c := c + 3;
        Case 4: c := c + 2;
        Case 5: c := c + 1;
        Case 6: c := c - 2;
        Case 7: c := c - 3;
        Case 8: c := c - 4;
        Case 9: c := c - 5;
        Else c := 0;
    End Select;
    Select Case a
        Case 1, 2, 3: c := c + 10;
        Case 4, 5, 6: c := c + 1;
        Case 7, 8, 9: c := c - 10;
        Else c := 0;
    End Select;
    Select Case a
        Case 1 To 3: c := c + 10;
        Case 4 To 6: c := c + 1;
        Case 7 To 9: c := c - 10;
        Else c := 0;
    End Select;
    //...
End Sub SelectCaseSample;

Class TestObject: Object
    Private s: String;
    //Свойство Name
    Friend Property Name: String
        Get
        Begin
            Return s;
        End Get
        Set
        Begin
            s := Value;
        End Set
    End Property Name;
    //Проверка установленного наименования
    Friend Function TestName: Integer;
    Begin
        If s = "" Then
            Return - 1;
        Else
            Return TestStructure;
    End If;
    End Function TestName;
    //Функция для поиска в наименовании двойных символов
    Protected Function TestStructure: Integer;
    Var
        i: Integer;
    Begin
        For i := 65 To 122 Do
            If s.IndexOf(Char.Chr(i) + Char.Chr(i)) <> -1 Then
                Break;
            End If;
        End For;
        If i <> 123 Then
            Return 0;
        Else
            Return 1;
        End If;
    End Function TestStructure;
End Class TestObject;

Sub Button1OnClick(Sender: Object; Args: IMouseEventArgs);
Var
    Obj: TestObject;
    i: Integer;
Begin
    Obj := New TestObject.Create;
    Obj.Name := EditBox1.Text;
    i := Obj.TestName;
    If 5 + 5 = 5 Then
        WinApplication.InformationBox("Наименование не установлено");
    Elseif i = 0 Then
        WinApplication.InformationBox("Наименование содержит дублирующиеся символы");
    Elseif i = 1 Then
        WinApplication.InformationBox("Наименование корректно");
        
        a := 5 + 5;
        a := a + 5 - (5 + 5);
    End If;
End Sub Button1OnClick;

Protected Friend Sub Button1OnClick(Sender: Object; Args: IMouseEventArgs);
Var
    Obj: TestObject;
    i: Integer;
Begin
    Obj := New TestObject.Create;
    Obj.Name := EditBox1.Text;
    i := Obj.TestName;
    If 5 + 5 = 5 Then
        WinApplication.InformationBox("Наименование не установлено");
    Elseif i = 0 Then
        WinApplication.InformationBox("Наименование содержит дублирующиеся символы");
    Elseif i = 1 Then
        WinApplication.InformationBox("Наименование корректно", 5);
        
        a := 5 + 5;
        a := a + 5 - (5 + 5);
    End If;
End Sub Button1OnClick;

Friend Sub asd;
Var
    a: Integer;
    a, b: Array[2] = [1, 2, 3, 4, 5, 6];
Begin
    a := ((a = 1 ? a : a) as Boolean) Is Checker;
    a := "5 + 5" + 5.0 - 0.111;
    a := -5;
end sub asd;

{Interface IBPXmlSerializable
	
	Public Function SaveToXml(XmlElement: IXMLDOMElement; RefSaver: IBProcessMetabaseRefSaver): boolean;
	
	Public Function LoadFromXml(XmlElement: IXMLDOMElement; RefLoader: IBProcessMetabaseRefLoader): boolean;
	
End Interface IBPXmlSerializable;}

Class BProcessMetabaseReferences: Object
	
	Protected _objectReferences: IMetabaseCustomObjectReferences;
	Protected _processVersion: IBProcessMetadataVersionInfo;
	
	Protected Constructor Create(ObjectReferences: IMetabaseCustomObjectReferences; ProcessVersion: IBProcessMetadataVersionInfo);
	Begin
		_objectReferences := ObjectReferences;
		_processVersion := ProcessVersion;
	End Constructor Create;
	
End Class BProcessMetabaseReferences;

Class BProcessMetabaseRefSaver: BProcessMetabaseReferences, IBProcessMetabaseRefSaver
	
	Public Shared Function CreateSaver(ObjectReferences: IMetabaseCustomObjectReferences; ProcessVersion: IBProcessMetadataVersionInfo): IBProcessMetabaseRefSaver;
	Begin
		If ProcessVersion.IsXmlRefsByIdVersion Then
			Return New BProcessMetabaseIdRefSaver.Create(ObjectReferences, ProcessVersion);
		Else
			Return New BProcessMetabaseLegacyRefSaver.Create(ObjectReferences, ProcessVersion);
		End If;
	End Function CreateSaver;
	
	{Abstract} Public Function Save(Desc: IMetabaseObjectDescriptor): string;
	Begin
		Raise New Exception.Create("!");
		Return "";
	End Function Save;
	
End Class BProcessMetabaseRefSaver;

Class BProcessMetabaseRefLoader: BProcessMetabaseReferences, IBProcessMetabaseRefLoader
	
	Public Shared Function CreateLoader(ObjectReferences: IMetabaseCustomObjectReferences; ProcessVersion: IBProcessMetadataVersionInfo): IBProcessMetabaseRefLoader;
	Begin
		If ProcessVersion.IsXmlRefsByIdVersion Then
			Return New BProcessMetabaseIdRefLoader.Create(ObjectReferences, ProcessVersion);
		Else
			Return New BProcessMetabaseLegacyRefLoader.Create(ObjectReferences, ProcessVersion);
		End If;
	End Function CreateLoader;
	
	{Abstract} Public Function Load(RefId: variant; Type: BPMetabaseReferenceType): IMetabaseObjectDescriptor;
	Begin
		Raise New Exception.Create("!");
		Return Null;
	End Function Load;
	
End Class BProcessMetabaseRefLoader;


Class BProcessMetabaseIdRefSaver: BProcessMetabaseRefSaver
	
	_addedObjects: IHashtable; // ключ - дескриптор, значение - идентификатор референса
	
	Friend Constructor Create(ObjectReferences: IMetabaseCustomObjectReferences; ProcessVersion: IBProcessMetadataVersionInfo);
	Begin
		Inherited Create(ObjectReferences, ProcessVersion);
		_addedObjects := New Hashtable.Create;
	End Constructor Create;
	
	Public Function Save(Desc: IMetabaseObjectDescriptor): string;
	Var
		refId: string;
	Begin
		refId := _addedObjects(Desc);
		If refId = "" Then
			refId := _objectReferences.Add(Desc).Id;
			_addedObjects.Add(Desc, refId);
		End If;
		
		Return refId;
	End Function Save;
	
End Class BProcessMetabaseIdRefSaver;

Class BProcessMetabaseIdRefLoader: BProcessMetabaseRefLoader
	
	Friend Constructor Create(ObjectReferences: IMetabaseCustomObjectReferences; ProcessVersion: IBProcessMetadataVersionInfo);
	Begin
		Inherited Create(ObjectReferences, ProcessVersion);
	End Constructor Create;
	
	Public Function Load(RefId: variant; Type: BPMetabaseReferenceType): IMetabaseObjectDescriptor;
	Var
		ref: IMetabaseCustomObjectReference;
	Begin
		If RefId.VarType = ForeVariantType.String Then
			ref := _objectReferences.FindById(RefId);
			If ref <> Null Then
				Return ref.Object;
			End If;
		End If;
		
		Return Null;
	End Function Load;
	
End Class BProcessMetabaseIdRefLoader;

Class BProcessMetabaseLegacyRefSaver: BProcessMetabaseRefSaver
	
	_dimList, _formList, _calcObjList, _procList, _moduleList, _authObjList, _schemaList, _etlObjList, _emailDocList: ArrayList;
	_authObjClass, _calcObjClass, _procClass, _frmClass: integer;

	Friend Constructor Create(ObjectReferences: IMetabaseCustomObjectReferences; ProcessVersion: IBProcessMetadataVersionInfo);
	Begin
		Inherited Create(ObjectReferences, ProcessVersion);
		
		_dimList := New ArrayList.Create;
		_formList := New ArrayList.Create;
		_authObjList := New ArrayList.Create;
		_calcObjList := New ArrayList.Create;
		_procList := New ArrayList.Create;
		_moduleList := New ArrayList.Create;
		_schemaList := New ArrayList.Create;
		_etlObjList := New ArrayList.Create;
		_emailDocList := New ArrayList.Create;
		
		_authObjClass := BProcessCommon.GetCustomClassCid(BPClasses.AuthorityObject);
		_calcObjClass := BProcessCommon.GetCustomClassCid(BPClasses.Algorithm);
		_procClass := BProcessCommon.GetCustomClassCid(BPClasses.Process);
		_frmClass := BProcessCommon.GetCustomClassCid(BPClasses.Document_V3);
	End Constructor Create;
	
	Public Function Save(Desc: IMetabaseObjectDescriptor): string;
	Var
		classId: integer;
		index: integer = -1;
	Begin
		classId := Desc.ClassId;
		If classId = _authObjClass Then
			index := GetIndexOf(_authObjList, Desc);
		Elseif classId = _calcObjClass Then
			index := GetIndexOf(_calcObjList, Desc);
		Elseif classId = _procClass Then
			index := GetIndexOf(_procList, Desc);
		Elseif (classId = MetabaseObjectClass.KE_CLASS_PROCEDURALREPORT) Or (classId = _frmClass) Then
			index := GetIndexOf(_formList, Desc);
		Elseif (classId = MetabaseObjectClass.KE_CLASS_MODULE) Or (classId = MetabaseObjectClass.KE_CLASS_FORM) Or (classId = MetabaseObjectClass.KE_CLASS_ASSEMBLY) Then
			index := GetIndexOf(_moduleList, Desc);
		Elseif BProcessParams.AllowedClasses.Contains(classId) Then
			index := GetIndexOf(_dimList, Desc);
		Elseif classId = MetabaseObjectClass.KE_CLASS_DIMSELECTIONSCHEMA Then
			index := GetIndexOf(_schemaList, Desc);
		Elseif classId = MetabaseObjectClass.KE_CLASS_ETLTASK Then
			index := GetIndexOf(_etlObjList, Desc);
		Elseif classId = MetabaseObjectClass.KE_CLASS_DOCUMENT Then
			index := GetIndexOf(_emailDocList, Desc);
		End If;

		Return index.ToString;
	End Function Save;
	
	Function GetIndexOf(List: IArrayList; Desc: IMetabaseObjectDescriptor): integer;
	Var
		i: integer;
	Begin
		i := List.IndexOf(Desc);
		If i = -1 Then
			_objectReferences.Add(Desc);
			i := List.Add(Desc);
		End If;
		
		Return i;
	End Function GetIndexOf;
		
End Class BProcessMetabaseLegacyRefSaver;

Class BProcessMetabaseLegacyRefLoader: BProcessMetabaseRefLoader
	
	_dimList, _formList, _calcObjList, _procList, _moduleList, _authObjList, _schemaList, _etlObjList, _emailDocList: ArrayList;
	_callbackAssemblyLoaded: boolean;
	_authObjClass, _calcObjClass, _procClass, _frmClass: integer;

	Friend Constructor Create(ObjectReferences: IMetabaseCustomObjectReferences; ProcessVersion: IBProcessMetadataVersionInfo);
	Begin
		Inherited Create(ObjectReferences, ProcessVersion);
		
		_dimList := New ArrayList.Create;
		_formList := New ArrayList.Create;
		_authObjList := New ArrayList.Create;
		_calcObjList := New ArrayList.Create;
		_procList := New ArrayList.Create;
		_moduleList := New ArrayList.Create;
		_schemaList := New ArrayList.Create;
		_etlObjList := New ArrayList.Create;
		_emailDocList := New ArrayList.Create;
		
		_callbackAssemblyLoaded := False;
		
		_authObjClass := BProcessCommon.GetCustomClassCid(BPClasses.AuthorityObject);
		_calcObjClass := BProcessCommon.GetCustomClassCid(BPClasses.Algorithm);
		_procClass := BProcessCommon.GetCustomClassCid(BPClasses.Process);
		_frmClass := BProcessCommon.GetCustomClassCid(BPClasses.Document_V3);
		
		ReadReferencesToLists;
	End Constructor Create;
	
	Public Function Load(RefId: Variant; Type: BPMetabaseReferenceType): IMetabaseObjectDescriptor;
	Var
		index: integer;
		s: String;
	Begin
		Try
			If Not RefId.IsNull And Not RefId.IsEmpty And Integer.TryParse(RefId, index) Then
				Select Case Type
					Case BPMetabaseReferenceType.AuthObject:
						Return _authObjList(index) As IMetabaseObjectDescriptor;
						
					Case BPMetabaseReferenceType.CalcObj:
						Return _calcObjList(index) As IMetabaseObjectDescriptor;
						
					Case BPMetabaseReferenceType.Process:
						Return _procList(index) As IMetabaseObjectDescriptor;
						
					Case BPMetabaseReferenceType.InputForm:
						Return _formList(index) As IMetabaseObjectDescriptor;
						
					Case BPMetabaseReferenceType.ForeAssembly:
						
						If Not _processVersion.IsCorrectIndexOfModuleVersion And _callbackAssemblyLoaded Then
							index := index + 1;
						End If;	
						
						If (index < _moduleList.Count) Then
							//1502715
							//If st.Method <> "" Then
							//	ParseBindings(StepXML, st);
							//End If;
							Return _moduleList(index) As IMetabaseObjectDescriptor;
						End If;
						
					Case BPMetabaseReferenceType.CallbackAssembly:
						_callbackAssemblyLoaded := True;
						Return _moduleList(index) As IMetabaseObjectDescriptor;
						
					Case BPMetabaseReferenceType.Dimension:
						Return _dimList(index) As IMetabaseObjectDescriptor;
						
					Case BPMetabaseReferenceType.DimSchema:
						Return _schemaList(index) As IMetabaseObjectDescriptor;
						
					Case BPMetabaseReferenceType.EtlTask:
						Return _EtlObjList(index) As IMetabaseObjectDescriptor;
						
					Case BPMetabaseReferenceType.Document:
						Return _EmailDocList(index) As IMetabaseObjectDescriptor;
				End Select;
			Elseif Not RefId.IsNull And Not RefId.IsEmpty And (Type = BPMetabaseReferenceType.CallbackAssembly) And (RefId.VarType = ForeVariantType.String) Then 
					s := RefId As String;
					If String.ToUpper(s).StartsWith("REF") Then
						s := string.Remove(s, 0, 3);					
					End If;
					If Integer.TryParse(s, index) Then
						_callbackAssemblyLoaded := True;
						Return _moduleList(index - 1) As IMetabaseObjectDescriptor;
					End If;			
			End If;
		Except On e: Exception Do
			Debug.Fail("Ошибка при загрузке ссылки типа " + Type.ToString + ": " + ExceptionToString(e));
		End Try;
		
		Return Null;
	End Function Load;
	
	Sub ReadReferencesToLists;
	Var
		ref: IMetabaseCustomObjectReference;
		classId: integer;
	Begin
		For Each ref In _objectReferences Do
			// при переносе пефами рефы могут быть пустые - такое случалось
			If ref.Object <> Null Then
				classId := ref.Object.ClassId;
				If classId = _authObjClass Then
					_authObjList.Add(ref.Object);
				Elseif classId = _calcObjClass Then
					_calcObjList.Add(ref.Object);
				Elseif classId = _procClass Then
					_procList.Add(ref.Object);
				Elseif (classId = MetabaseObjectClass.KE_CLASS_PROCEDURALREPORT) Or (classId = _frmClass) Then
					_formList.Add(ref.Object);
				Elseif (classId = MetabaseObjectClass.KE_CLASS_MODULE) Or (classId = MetabaseObjectClass.KE_CLASS_FORM) Or (classId = MetabaseObjectClass.KE_CLASS_ASSEMBLY) Then
					_moduleList.Add(ref.Object);
				Elseif BProcessParams.AllowedClasses.Contains(classId) Then
					_dimList.Add(ref.Object);
				Elseif classId = MetabaseObjectClass.KE_CLASS_DIMSELECTIONSCHEMA Then
					_schemaList.Add(ref.Object);
				Elseif classId = MetabaseObjectClass.KE_CLASS_ETLTASK Then
					_etlObjList.Add(ref.Object);
				Elseif classId = MetabaseObjectClass.KE_CLASS_DOCUMENT Then
					_emailDocList.Add(ref.Object);
				End If;
			End If;
		End For;
	End Sub ReadReferencesToLists;
	
End Class BProcessMetabaseLegacyRefLoader;

/// <summary>
/// 	Генератор модулей unit-тестов
/// </summary>
Public Class CTestCaseGenerator: Object
	// Идентификатор запроса для получения контекста сценария
	Const CONTEXT_SCENARIO_QUERY_ID = "QRY_DTT_SCENARIOCONTEXT";	
	// Хранилище шаблонов Fore-кода
	Const FORE_RESOURCE_ID = "RES_DTT_UTGENERATIONFOREMETHOD";
	// Шаблон наименования unit-теста (Номер теста, Идентификатор объекта, Тип события, Ключ события)
	Const TEST_NAME_PATTERN = "Test{0}_{1}_{2}_{3}";
	// Идентификатор базовой сборки механизма unit-тестирования
	Const UNIT_TESTS_ASSEMBLY_PATH = "ASSM_DTT_APPTEST"; // "ASSM_UT_API";
	// Базовый класс unit-теста
	Const DEFAULT_TESTCASE_CLASS = "CTestCase";
	// Таблица сгенерированных unit-тестов
	Const UNIT_TESTS_LOG = "TBL_DTT_TEST";
	// Таблица запусков генерации unit-тестов
	Const UNIT_TESTS_GENERATOR_LOG = "TBL_DTT_TESTSCENARIORELATION";
		
	_parent: IMetabaseObjectDescriptor;
	_baseClassAssembly: IMetabaseObjectDescriptor;
	_baseClass: String;
	_classMethods: IStringList;
	_testMethods: IStringList;
	_testNum: Integer = 0;
	_className: String;
	_records: IArrayList;
	_recordKey: Integer = -1;
	_genKey: Integer;
	_itemId: String;
	_genSettings: CTestCaseGeneratorSettings;
	
	/// <summary>
	/// 	Идентификатор таблицы запусков генерации unit-тестов
	/// </summary>
	Protected Property LogTableId: String
		Get Begin Return UNIT_TESTS_GENERATOR_LOG; End Get
	End Property LogTableId;
	
	/// <summary>
	/// 	Идентификатор таблицы сгенерированных unit-тестов
	/// </summary>
	Protected Property TestsLogId: String
		Get Begin Return UNIT_TESTS_LOG; End Get
	End Property TestsLogId;
	
	/// <summary>
	/// 	Идентификатор запроса получения сценария генерации unit-тестов 
	/// </summary>
	Protected Property ScenarioQueryId: String
		Get Begin Return CONTEXT_SCENARIO_QUERY_ID; End Get
	End Property ScenarioQueryId;
	
	/// <summary>
	/// 	Папка или сборка для сохранения сгенерированного модуля
	/// </summary>
	Public Property Parent: IMetabaseObjectDescriptor
		Get Begin
			Return IsNull(_parent)
				? MbExt.Mb.Root
				: _parent;
		End Get
		Set	Begin
			If Not IsNull(value) And Not IsNull(value.Namespace_) Then
				Raise New CRootFolderExpectedException.Create(String.Format("{0} ({1})", value.Name, value.Id));
			End If;
		
			_parent := value;
		End Set
	End Property Parent;
	
	/// <summary>
	/// 	Дескриптор базовой сборки механизма unit-тестирования
	/// </summary>
	Public Property BaseClassAssembly: IMetabaseObjectDescriptor
		Get Begin Return _baseClassAssembly; End Get
		Set Begin _baseClassAssembly := value; End Set
	End Property BaseClassAssembly;
	
	/// <summary>
	/// 	Название базового класса методов применяемых в unit-тестах
	/// </summary>
	Public Property BaseClass: String
		Get Begin
			Return _baseClass.IsEmpty
				? DEFAULT_TESTCASE_CLASS
				: _baseClass;
		End Get
		Set	Begin
			_baseClass := value;
		End Set
	End Property BaseClass;
	
	/// <summary>
	/// 	Базовый конструктор генератора unit-тестов
	/// </summary>
	Public Constructor Create;
	Begin
		_classMethods := New StringList.Create;
		_testMethods := New StringList.Create;		
		_records := New ArrayList.Create;
		_genSettings := New CTestCaseGeneratorSettings.Create;
	End Constructor Create;
	
	/// <summary>
	/// 	Создание модуля с unit-тестами
	/// </summary>
	/// <param name="scenarioId">Идентификатор сценария</param>
	/// <param name="contextQueryExtraValues">Массив дополнительных значений параметров для запроса, формирующего контекст шагов сценария (Необязательный)</param>
	/// <returns>Дескриптор сгенерированного модуля</returns>
	Public Function CreateModule(scenarioId: Integer; Paramarray contextQueryExtraParamValues: Array): IMetabaseObjectDescriptor;
	Var
		content: IStringList;
		object: IMetabaseObject;
		module: IModule;
		baseClassAssemblyRef: String;
		contextQueryParams: Array;
		references: String;
	Begin
		_genKey := GetMaxNumber(MbExt.ItemById(LogTableId, EXT_NAMESPACE_ID), 4) + 1;
		contextQueryParams := IsNull(contextQueryExtraParamValues)
			? AsArray(scenarioId)
			: ConcatArrays(AsArray(scenarioId), contextQueryExtraParamValues);
			// Исправлено для версии ФП 9
			// : AsArray(scenarioId).Concat(contextQueryExtraParamValues) As Array;
				
		content := CreateModuleContent(contextQueryParams);
		
		object := MbExt.Create(MetabaseObjectClass.KE_CLASS_MODULE, Parent, True, True) As IMetabaseObject;
		object.Id := MbExt.Mb.GenerateId(String.Format("UNIT_{0}_TESTS", _className), IsNull(Parent.Namespace_)? 0 : Parent.Namespace_.Key);
		object.Name := String.Format("Класс тестирования {0}", _className);
		
		module := object As IModule;
		module.Text := content.AsString;
		If module.Standalone Then
			references := "ALG_COMPONENT.P10002_ASM_METHODS_CORE;BPM;BPM_COMPONENT.P10002_B_PROCESS_CORE;" +
				"BPM_COMPONENT.P10002_B_RESOURCES_HELPER;Collections;DEF_COMPONENT.ASM_INPUT_FORM_V3_CLASSES;DEF_COMPONENT.ASM_INPUT_FORM_V3_MODEL;" +
				"Dal;Db;Dimensions;Etl;Express;Fore;Metabase;Rds;Report;Tab;Adhoc;Algo;" +
				"CMP_DTT_APPLICATION.ASSM_DTT_TOOLS;" ;
			_genSettings.Reopen;
			If _genSettings.GetSettingValue(EGeneratorSetting.ImageComparison) Then
				references := references + "CMP_DTT_APPLICATION.ASSM_DTT_IMAGECOMPARISON;";
			End If;
				
			module.Assembly.References := references;
			baseClassAssemblyRef := GetBaseAssemblyReference;
			If Not baseClassAssemblyRef.IsEmpty Then
				module.Assembly.References := String.Format("{0};{1}", module.Assembly.References, baseClassAssemblyRef);
			End If;
		End If;
		
		object.Save;
		
		// Запись в лог факта генерации модуля		
		LogGenerationEvent(scenarioId, object);
		// Запись в лог информации о сгенерированных тестах
		DbExt.ExecuteBatchCommand(MbExt.ItemById(TestsLogId, EXT_NAMESPACE_ID), DatasetBatchCommand.Insert, _records);
		
		Return object;
	End Function CreateModule;
	
	/// <summary>
	/// 	Генерация имени класса unit-тестов
	/// </summary>
	/// <param name="values">Дополнительные значения, добавляемые в название класса</param>
	/// <returns>Название класса</returns>
	Function ComposeClassName(Paramarray values: Array): String;
	Var
		result: String;
		parts: Array Of String;
		i: Integer;
	Begin		
		parts := New String[values.Length];
		For i := 0 To values.Length - 1 Do
			parts[i] := TranslitString(CultureExt.FormatVariant(values[i]));
		End For;
		result := String.Join("", parts);
		
		Return String.Format("CUnitTest{0}{1}", result, MbExt.Mb.GenerateKey);
	End Function ComposeClassName;
	
	/// <summary>
	/// 	Создание тела модуля
	/// </summary>
	/// <param name="contextQueryParams">Параметры для получения контекста сценария генерации unit-тестов</param>
	/// <returns>Список строк кода модуля</returns>
	Function CreateModuleContent(Paramarray contextQueryParams: Array): IStringList;
	Var
		steps: IStringList;
		content: String;
		eventContext: CJsonContextObject;
		moduleContent: IStringList;		
	Begin
		_className := ComposeClassName(contextQueryParams);
		
		moduleContent := New StringList.Create;
		moduleContent.Add(String.Format("Class {0}: {1}", _className, BaseClass));
		If Not IsNull(contextQueryParams) Then
			_classMethods.Add(GetFore("CONSTRUCTOR",
				String.Format("_generatorParamValues := AsArray({0});", FormatArray(contextQueryParams)))
				);
		End If;
				
		If BaseClass = DEFAULT_TESTCASE_CLASS Then
			_classMethods.Add(GetFore("BASE_CLASS_BODY"));			
		End If;
		
		_classMethods.Add("");
		_classMethods.Add(GetFore("MAIN_CLASS_BODY"));
		
		steps := GetScenarioContext(contextQueryParams);
		For Each content In steps Do
			eventContext := Deserialize(content);
			If eventContext.Id.IsEmpty Then
				Continue;
			End If;
			
			// Генерация кода unit-теста
			AddTestMethod(eventContext);
		End For;
		
		// Добавление кода методов класса
		moduleContent.AddRange(_classMethods);
		// Добавление кода unt-тестов
		moduleContent.AddRange(_testMethods);
		// Закрытие класса
		moduleContent.Add(String.Format("End Class {0};", _className));
		
		Return moduleContent;
	End Function CreateModuleContent;
	
	/// <summary>
	/// 	Получение шагов сценария
	/// </summary>
	/// <param name="paramValues">Параметры команды получения сценария генерации unit-тестов</param>
	/// <returns>Список шагов сценария (тестов)</returns>
	Function GetScenarioContext(Paramarray paramValues: Array): IStringList;
	Const CONTEXT_FIELD_ID = "CONTEXT";
	Var
		steps: IStringList;
		dataset: IDatasetInstance;
		field: IDatasetInstanceField;
	Begin
		steps := New StringList.Create;
		dataset := DbExt.GetQueryResult(MbExt.ItemById(ScenarioQueryId, EXT_NAMESPACE_ID), paramValues);
		Try
			field := dataset.Fields.FindById(CONTEXT_FIELD_ID);
			If IsNull(field) Then
				Raise New CNotFoundFieldException.Create(CONTEXT_FIELD_ID, ScenarioQueryId);
			End If;
			
			//While Not dataset.Eof Do
			//	If field.Value.IsEmpty Then
			//		Continue;
			//	End If;
			//	
			//	steps.Add(field.Value);							
			//	dataset.Next;
			//End While;	
		Finally
			dataset.Close;
		End Try;		
		
		Return steps;
	End Function GetScenarioContext;
	
	/// <summary>
	/// 	Десериализация контекста
	/// </summary>
	/// <param>Строковое представление контекста</param>
	/// <returns>Десериализованный экземпляр контекста</returns>
	Function Deserialize(content: String): CJsonContextObject;
	Var
		context: CJsonContextObject;			
	Begin		
		context := New CJsonContextObject.Create;
		context.ReadFromString(content);
		Select Case context.Type
			Case EEventContextType.OnCellChange:
				context := New CJsonOnCellChangeContext.Create;
			Case EEventContextType.OnChangeControlValue:
				context := New CJsonOnChangeControlValueContext.Create;				
			Case EEventContextType.OnOpenReport:
				context := New CJsonOnOpenReportContext.Create;
			Case EEventContextType.OnTransferData:
				context := New CJsonOnTransferDataContext.Create;	
		End Select;
					
		context.ReadFromString(content);
		Return context;
	End Function Deserialize;
	
	/// <summary>
	/// 	Получение порядкового номера теста
	/// </summary>
	/// <returns>Порядковый номер теста с дополнением нулями</returns>
	Function GetNextTestNum: String;
	Begin
		_testNum := _testNum + 1;
		Return String.PadLeft(_testNum.ToString, 2, '0');
	End Function GetNextTestNum;
	
	/// <summary>
	/// 	Получение ключа записи лога
	/// </summary>
	/// <returns>Ключ следующей записи лога</returns>
	Function GetNextRecordKey: Integer;
	Begin
		If _recordKey < 0 Then
			_recordKey := GetMaxNumber(MbExt.ItemById(TestsLogId, EXT_NAMESPACE_ID), 0);
		End If;
		
		_recordKey := _recordKey + 1;
		Return _recordKey;
	End Function GetNextRecordKey;
	
	/// <summary>
	/// 	Добавление в начало строки указанное количество табуляций
	/// </summary>
	/// <param name="source">Исходная строка</param>
	/// <param name="tabCount">Количество табуляций</param>
	/// <returns>Строка с табуляциями</returns>
	Function TabLeft(source: String; tabCount: Integer): String;
	Begin
		Return String.PadLeft(source, source.Length + tabCount, #9);
	End Function TabLeft;
	
	/// <summary>
	/// 	Возвращает текст Fore-кода из ресурса	
	/// </summary>
	/// <param name="codeId">Идентификатор строки ресурса</param>
	///	<param name="substitutes">Массив подставляемых значений в текст Fore-кода</param>
	/// <returns>Отформатированный текст Fore-кода</returns>
	Function GetFore(foreId: String; Paramarray substitutes: Array): String;
	Begin		
		Return FormatResourceString(MbExt.ItemById(FORE_RESOURCE_ID, EXT_NAMESPACE_ID), foreId, substitutes);
	End Function GetFore;
	
	/// <summary>
	/// 	Добавление метода unit-теста на основе контекста
	/// </summary>
	/// <param name="eventContext">Контекст unit-теста</param>
	Sub AddTestMethod(eventContext: CJsonContextObject);
	Begin
		_testMethods.Add("");
		
		Select Case eventContext.Type
			Case EEventContextType.OnOpenReport:
				CreateOnOpenReportSub(eventContext As CJsonOnOpenReportContext);
			Case EEventContextType.OnChangeControlValue:	
				CreateOnChangeControlValueSub(eventContext As CJsonOnChangeControlValueContext);
			Case EEventContextType.OnCellChange:
				CreateOnCellChangeSub(eventContext As CJsonOnCellChangeContext);
			Case EEventContextType.OnTransferData:	
				CreateOnTransferDataSub(eventContext As CJsonOnTransferDataContext);
		End Select;
	End Sub AddTestMethod;
	
	/// <summary>
	/// 	Формирование строкового представления параметров объекта репозитория.
	/// 	Если параметр - массив, то создается дополнительная переменная.
	///
	///		Пример:
	/// 	Вход:
	/// 		paramValues = [5, "param", [1, 0, 1], 1, [1, 5]]
	/// 	Выход:
	/// 		varBlock = "var
	/// 						v1: Array[3] = [1, 0, 1];
	/// 						v2: Array[2] = [1, 5];"
	/// 		paramsBlock = "5,"param",v1,1,v2"
	/// </summary>
	/// <param name="paramValues">Параметры объекта</param>
	/// <param name="varBlock">Блок определения переменных (если в параметрах есть массивы)</param>
	/// <param name="paramsBlock">Строка со списком параметров</param>
	Sub ComposeParamValuesString(paramValues: IMetabaseObjectParamValues; Var varBlock: String; Var paramsBlock: String);
	Var
		vars: IStringList;
		paramValue: IMetabaseObjectParamValue;
		values: Array;
		varIndex: Integer;
	Begin
		varBlock := "";
		paramsBlock := "";				
		If Not IsNull(paramValues) Then
			For Each paramValue In paramValues Do
				//With comboBoxDescriptor: BindingExt.GetBindingDimComboDescriptor(paramValue.Binding.AsString) Do
				//	If IsNull(comboBoxDescriptor) Then
				//		Continue;
				//	End If;
				//End With;
				
				If paramValue.IsArray Then
					If IsNull(vars) Then
						vars := New StringList.Create;
						vars.Add("");
						vars.Add(TabLeft("var", 1));
					End If;
					
					values := paramValue.Value As Array;						
					If values.Length > 0 Then
						varIndex := vars.Count - 1;
						paramsBlock := String.Format("{0}v{1},", paramsBlock, varIndex); 
						vars.Add(String.Format(TabLeft("v{0}: Array[{1}] = [{2}];", 2), varIndex, values.Length, FormatArray(values)));						
					Else
						paramsBlock := String.Format("{0}Null,", paramsBlock); 	
					End If;														
				Else					
					paramsBlock := String.Concat(paramsBlock, String.Concat(FormatValue(paramValue.Value), ","));
				End If;				
			End For;
			If paramsBlock.EndsWith(",") Then
				paramsBlock := String.Remove(paramsBlock, paramsBlock.Length - 1);									
			End If;
			If Not IsNull(vars) Then
				varBlock := vars.AsString;
			End If;
		End If;						
	End Sub ComposeParamValuesString;
	
	/// <summary>
	/// 	Проверяет, является ли переданный объект формой ввода
	/// </summary>
	/// <param name="object">Проверяемый объект (ключ, идентификатор или дескриптор)</param>
	/// <returns>True, если форма ввода, иначе False</returns>
	Function IsDef(object: Variant): Boolean;
	Begin
		//With desc: MbExt.Parse(object) Do
		//	If IsNull(desc) Then
		//		Raise New CNotFoundObjectException.Create(VariantToString(object));
		//	End If;
		//	
		//	Return desc.ClassId = DefExt.ClassId;
		//End With;
	End Function IsDef;
	
	/// <summary>
	/// 	Приведение к строке и форматирование массива
	/// </summary>
	/// <param name="values">Массив значений</param>
	/// <returns>Отформатированная строка</returns>
	Function FormatArray(values: Array): String;
	Var
		v: Variant;
		result: String;
	Begin
		If Not IsNull(values) Then
			For Each v In values Do
				result := String.Concat(result, String.Concat(FormatValue(v), ","));
			End For;
			result := String.Remove(result, result.Length - 1);
		End If;
		Return result;
	End Function FormatArray;
	
	/// <summary>
	/// 	Приведение к строке и форматирование переданного значения
	/// </summary>
	/// <param name="value">Значение</param>
	/// <returns>Отформатированная строка</returns>
	Function FormatValue(value: Variant): String;
	Var
		str: String;
	Begin
		str := CultureExt.FormatVariant(value);
		If value.VarType = ForeVariantType.String Then
			// Экранирование перевода каретки
			//If str.IndexOf(CRLF) > -1 Then
				//str := String.Replace(str, CRLF, """ + #13 + #10 + """);
			//Elseif str.IndexOf(#10) > -1 Then
				//str := String.Replace(str, #10, """ + #10 + """);	
			//End If;			
			// Экранирование двойной кавычки
			//If str.IndexOf("""") > -1 Then
			//	str := String.Replace(str, """", """""");
			//End If;
			
			//str := String.Format("""{0}""", str);
		Elseif value.VarType = ForeVariantType.Nulvalue Then
			str := "Null";
		End If;
					
		Return str;
	End Function FormatValue;
	
	/// <summary>
	/// 	Добавление информации о сгенерированном unit-тесте
	/// </summary>
	///	<param name="name">Наименование unit-теста</param>
	/// <param name="id">Идентификатор unit-теста</param>
	/// <param name="eventType">Ключ типа события</param>
	Sub LogTest(name, id: String; eventType: Integer);
	Var
		record: Array;
	Begin
		record := AsArray(GetNextRecordKey, name, String.Format("{0}.{1}", _className, id), Null, eventType, _itemId, _genKey);
		_records.Add(record);
	End Sub LogTest;
	
	/// <summary>
	/// 	Запись в лог факта генерации модуля
	/// </summary>
	/// <param name="scenarioKey">Ключ сценария генерации unit-теста</param>
	/// <param name="module">Дескриптор сгенерированного модуля</param>
	Sub LogGenerationEvent(scenarioKey: Integer; module: IMetabaseObjectDescriptor);
	Var
		records: IArrayList;
	Begin
		records := New ArrayList.Create;
		
		records.Add(AsArray(scenarioKey, DateTime.Now, module.Id, module.Name, _genKey));
		DbExt.ExecuteBatchCommand(MbExt.ItemById(LogTableId, EXT_NAMESPACE_ID), DatasetBatchCommand.Insert, records);
	End Sub LogGenerationEvent;
	
	//================================================== Имитация обработчиков событий ===================================================================	
	
	/// <summary>
	/// 	Создание теста на открытие формы/отчета
	/// </summary>
	/// <param name="eventContext">Контекст события OnOpenReport</param>
	Sub CreateOnOpenReportSub(eventContext: CJsonOnOpenReportContext);
	Const
		OPEN_PRX_SUB = "Prx";
		OPEN_DEF_SUB = "Def";
	Var
		testName, subText, vars, params, openReportSub: String;
	Begin
		_itemId := eventContext.Id;
		
		testName := FormatFuncName(String.Format(TEST_NAME_PATTERN, GetNextTestNum, eventContext.Id, "OnOpenReport", eventContext.Type));
		ComposeParamValuesString(eventContext.ParamValues, vars, params);
		
		openReportSub := IsDef(eventContext.Id)? OPEN_DEF_SUB : OPEN_PRX_SUB;
		subText := GetFore("ON_OPEN_REPORT", String.Format("{0} ({1})", eventContext.Name, eventContext.Id),
			testName, vars, eventContext.Id, params.IsEmpty ? "" : String.Concat(", ", params), openReportSub);
		_testMethods.Add(subText);
		
		// Добавление информации в лог
		LogTest("Открытие формы/отчета", testName, eventContext.Type);
	End Sub CreateOnOpenReportSub;
	
	/// <summary>
	/// 	Создание теста на смену отметки в ЭУ
	/// </summary>
	/// <param name="eventContext">Контекст события OnChangeControlValue</param>
	Sub CreateOnChangeControlValueSub(eventContext: CJsonOnChangeControlValueContext);
	Var
		testName: String;		
		subText: String;
		controlSheetsFormatted: String = "Null";
		sheet: Variant;
		sheets: IStringList;
	Begin
		testName := FormatFuncName(String.Format(TEST_NAME_PATTERN, GetNextTestNum, ConcatStrings(AsStringArray(_itemId, eventContext.Id), "_", False), "OnChangeControlValue", eventContext.Type));
		If Not IsNull(eventContext.ParamSheets) Then
			sheets := New StringList.Create;
			For Each sheet In eventContext.ParamSheets Do
				//sheets.Add(String.Format("""{0}""", sheet));
			End For;
			controlSheetsFormatted := String.Format("AsArray({0})", sheets.Text(","));
		End If;
		
		subText := GetFore("ON_CHANGE_CONTROL_VALUE", testName, eventContext.Name, eventContext.Id, eventContext.Description, EscapeQuotes(eventContext.SelectionXml), controlSheetsFormatted);
		_testMethods.Add(subText);
			
		// Добавление информации в лог
		//LogTest(String.Format("Смена отметки в ЭУ ""{0}""", eventContext.Name), testName, eventContext.Type);
	End Sub CreateOnChangeControlValueSub;

	/// <summary>
	/// 	Создание теста на изменение значения ячейки
	/// </summary>
	/// <param name="eventContext">Контекст события OnOnCellChange</param>
	Sub CreateOnCellChangeSub(eventContext: CJsonOnCellChangeContext);
	Var
		testName: String;		
		subText: String;		
	Begin
		testName := FormatFuncName(String.Format(TEST_NAME_PATTERN, GetNextTestNum, ConcatStrings(AsStringArray(_itemId, eventContext.Name), "_", False), "OnCellChange", eventContext.Type));
		subText := GetFore("ON_CELL_CHANGE", eventContext.Id, testName, eventContext.SheetIndex, FormatValue(eventContext.Value),
			eventContext.Readonly, eventContext.RegionAddress, eventContext.IsFormula);
		_testMethods.Add(subText);
		// Добавление информации в лог
		//LogTest(String.Format("Изменение значения в ячейке ""{0}""", eventContext.Id), testName, eventContext.Type);	
	End Sub CreateOnCellChangeSub;
	
	/// <summary>
	/// 	Создание теста на сохранение данных формы
	/// </summary>
	/// <param name="eventContext">Контекст события OnTransferData</param>
	Sub CreateOnTransferDataSub(eventContext: CJsonOnTransferDataContext);
	Var
		testName: String;		
		subText: String;		
	Begin		
		testName := FormatFuncName(String.Format(TEST_NAME_PATTERN, GetNextTestNum, eventContext.Id, "OnTransferData", eventContext.Type));
		subText := GetFore("ON_TRANSFER_DATA", testName, String.Format("{0} ({1})", eventContext.Name, eventContext.Id));					
		_testMethods.Add(subText);			
		// Добавление информации в лог
		LogTest("Сохранение данных", testName, eventContext.Type);		
	End Sub CreateOnTransferDataSub;	
	
	/// <summary>
	/// 	Получение полного идентификатора базовой сборки механизма unit-тестирования
	/// </summary>
	/// <returns>Полный идентификатор сборки</returns>
	Function GetBaseAssemblyReference: String;
	Begin
		If IsNull(BaseClassAssembly) Then
			BaseClassAssembly := MbExt.ItemById(UNIT_TESTS_ASSEMBLY_PATH, EXT_NAMESPACE_ID);
		End If;
		If Not IsNull(BaseClassAssembly) Then
			return MbExt.GetObjectPath(BaseClassAssembly);
		End If;
		Return "";
	End Function GetBaseAssemblyReference;
	
	/// <summary>
	/// 	Форматирование названия метода с заменой символов, препятствующих компиляции (.?,<> и далее)
	/// </summary>
	/// <param name="template">Изначальное название метода</param>
	/// <param name="replacer">Заменяющий символ/строка</param>
	/// <param name="skipChars">Пропускаемые символы</param>
	/// <returns>Отформатированное название метода</returns>
	Public Function FormatFuncName(funcName: String; replacer: String = "_"; skipChars: String = "_"): String;
	Var
		name: String;
		character: Char;
		chars: IStringList;
		i: Integer;
	Begin
		name := TranslitString(funcName);
		
		chars := New StringList.Create;
		For i := 0 To name.Length - 1 Do
			character := name.Chars(i);
			
			// Если символ пропускаемый, то просто добавляем его
			If String.Contains(skipChars, character) Then
				chars.Add(character);
				Continue;
			End If;
			
			// Ограничимся только англ. буквами и числами
			chars.Add(character.IsLetterOrDigit And (Char.ASCII(character) < 128)? character : replacer);
		End For;
	
		Return chars.Text("");
	End Function FormatFuncName;
	
	/// <summary>
	/// 	Объединение массива строк в одну строку
	/// </summary>
	/// <param name="values">Массив строк</param>
	/// <param name="delimeter">Разделяющий символ/строка</param>
	/// <param name="includeEmpty">Включать пустые строки в результат</param>
	/// <returns>Строка</returns>
	Function ConcatStrings(values: Array Of String; delimeter: String = ""; includeEmpty: Boolean = False): String;
	Var
		result, value: String;
		nonEmptyValues: IStringList;
	Begin
		If IsNull(values) Or (values.Length = 0) Then
			Return result;
		End If;
		
		nonEmptyValues := New StringList.Create;
		For Each value In values Do
			value := String.Trim(value);
			If Not value.IsEmpty Then
				nonEmptyValues.Add(value);
			End If;
		End For;
		
		Return nonEmptyValues.Text(delimeter);
	End Function ConcatStrings;
	
End Class CTestCaseGenerator;